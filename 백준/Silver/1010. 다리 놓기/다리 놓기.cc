#include <iostream>
#include <algorithm>
#include <cmath>

#include <vector>

#define endl '\n'

using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	// 다리를 지을 수 있는 경우의 수

	// n = 1고 m = 1이면 => 1가지
	// n = 1고 m = 2이면 => 2가지
	// n = 1고 m = 3이면 => 3가지
	// n = 1고 m = 4이면 => 4가지

	// n = 2고 m = 2이면 => 1가지
	// n = 2고 m = 3이면 => 3가지
	// n = 2고 m = 4이면 => 6가지
	// n = 2고 m = 5이면 => 10가지
	// n = 2고 m = 6이면 => 15가지

	// n = 3고 m = 3이면 => 1가지
	// n = 3고 m = 4이면 => 4가지 (dp[2][3] + dp[3][3]) == (dp[2][3] + dp[2][2])
	// n = 3고 m = 5이면 => 10가지 (dp[2][4] + dp[3][4]) == (dp[2][4] + dp[2][3] + dp[2][2])
	// n = 3고 m = 6이면 => 20가지 (dp[2][5] + dp[3][5]) == (dp[2][5] + dp[2][4] + dp[2][3] + dp[2][2])

	// 일단 n = 2 기준으로,
	// m이 증가할 때 마다 경우의 수가 m - 1만큼 늘어나고 있어요.

	// n = 3까지 보았을 때, m이 늘어날 때 규칙을 확인할 수 있어요.
	// 다리 한 개를 고정시키고 나머지 다리를 기준으로 dp의 값을 확인한다고 생각하니 점화식이 나와요.

	// 예를 들어 n = 3, m = 5일 때, 다리 한 개를 첫 번째 사이트에 고정시켜 놓은 경우를 생각하면 n = 2, m = 4와 같은 상태가 되요.
	// 다리 한 개를 두 번째 사이트에 고정시켜 놓은 경우를 생각하면 n = 2, m = 3와 같은 상태가 되요.
	// 다리 한 개를 세 번째 사이트에 고정시켜 놓은 경우를 생각하면 n = 2, m = 2와 같은 상태가 되요.
	// 그러니 dp[3][5] = dp[2][4] + dp[2][3] + dp[2][2] 임을 알 수 있어요.
	// 그리고 이 것은 dp[3][5] = dp[2][4] + dp[3][4]로 요약할 수 있어요.

	// 이렇게 점화식을 세우면 n과 m의 값에 따라 경우의 수를 구할 수 있어요.

	vector<vector<int>> dp(31, vector<int>(31));

	for (int i = 1; i < 31; ++i)
	{
		dp[1][i] = i;
		dp[i][i] = 1;
	}

	for (int i = 2; i < 31; ++i)
	for (int j = i + 1; j < 31; ++j)
		dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];

	int T;
	cin >> T;

	while (T--)
	{
		int n, m;
		cin >> n >> m;
		cout << dp[n][m] << endl;
	}

	return 0;
}
